#include "header.h"

int main(int argc, const char* argv[]){
	ifstream trainFile,testFile;
	string singleline;
        if(argc != 4){
                cerr << "Invalid argument" << endl;
                return -1;
        }
        char type = *argv[3];

	trainFile.open(argv[1]);
	testFile.open(argv[2]);
	//If it cannot open the training set or the testing set, report an error and exit
	if(!trainFile){
		cerr<< "Error: Cannot open the training set!"<<endl;
		exit(-1);
	}
	if(!testFile){
		cerr<< "Error: Cannot open the test set!"<<endl;
		exit(-1);
	}

	Data traindata;
	Data testdata;
        //Read the attribute and instances
	while(getline(trainFile,singleline)){
                if(singleline[0] == '%')
                        continue;
		if(singleline[0] == '@'){
			traindata.parse_header(singleline);
		}else if(singleline.size() != 0)
			traindata.parse_data(singleline);
	}
	//Read the testing set*/

	while(getline(testFile,singleline)){
                if(singleline[0] == '%')
                        continue;
		if(singleline[0] == '@'){
			testdata.parse_header(singleline);
		}else if(singleline.size() != 0)
			testdata.parse_data(singleline);
	}
	cout << "Load Data Completed" << endl;
 vector<int> index;
        for(int i = 0; i < traindata.size(); i ++)
                index.push_back(i);

        vector<int> training_size;
        training_size.push_back(25);
        training_size.push_back(50);
        training_size.push_back(100);

        vector<vector<double> >test_NB_accuracy;
	vector<vector<double> >test_TB_accuracy;
        //For each size of training set, draw the instances randomly
        for(int i = 0; i < training_size.size(); i ++){
                int part_training_size = training_size[i];
                vector<double> part_test_accuracy;
		if(i == training_size.size()-1){
			part_traing_data = traindata;
		}
		for(int k = 0; k < 4; k ++){
			vector<vector<double> > part_training_data;

				



                //If the size is 200, only trains the model once
                if(training_size[i] == 100){
                        vector<vector<double> > part_training_data;
                        part_training_data = data;

                        double accuracy = TestTree(test_data,root);
                        part_test_accuracy.push_back(accuracy);
                }else{
                        int pos_num = (int)part_training_size*pos_port;
                        int neg_num = part_training_size - pos_num;
                        //Get the random training set ten times
                        for(int k = 0; k < 10; k++){
                                vector<vector<double> > part_training_data;
                                int cur_pos_num = 0;
                                int cur_neg_num = 0;
                                random_shuffle(index.begin(),index.end());
                                for(int j = 0; j < index.size() && cur_pos_num + cur_neg_num <= part_training_size; j ++){
                                        int cur_index = index[j];
                                        if(data[cur_index][data[cur_index].size()-1] == POS_CLASS){
                                                if(cur_pos_num >= pos_num) continue;
                                                cur_pos_num++;
                                                part_training_data.push_back(data[cur_index]);
                                        }
                                        if(data[cur_index][data[cur_index].size()-1] == NEG_CLASS){
                                                if(cur_neg_num >= neg_num) continue;
                                                cur_neg_num++;
                                                part_training_data.push_back(data[cur_index]);
                                        }
                                }
	                        Node* root = new Node;
                        	root->isLeaf = false;
                        	BuildTree(part_training_data,root,attr_table);
                                double accuracy = TestTree(test_data,root);
                                part_test_accuracy.push_back(accuracy);
                        }
                }
                test_accuracy.push_back(part_test_accuracy);
        }
        //Print the accuracy of each pretiction
        for(int i = 0; i < test_accuracy.size(); i ++){
                cout << "Training Size: " << training_size[i] << endl;
                for(int j = 0; j < test_accuracy[i].size(); j++)
                        cout << test_accuracy[i][j] << " ";
                cout << endl;
        }





        //traindata.printData();
        if(type == 'n'){
        	Bayes* naiveBayes = new Bayes(traindata);
	        naiveBayes->naiveBayes();
        	//naiveBayes->displayBayes();
        	naiveBayes->testNaiveBayes(testdata.getData());
        }else if(type == 't'){
                Bayes* tan = new Bayes(traindata);
                tan->TANBayes();
        	tan->displayBayes();
	        cout << "Begin Test" << endl;
                tan->testTANBayes(testdata.getData());
        }else
                cerr<<"Invalid argument" << endl;

}
